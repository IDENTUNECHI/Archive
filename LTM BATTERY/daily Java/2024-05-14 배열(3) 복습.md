## 정렬(Sort)

- 알고리즘의 시간적 효율은 작업에 필요한 연산 수로 측정한다.
	- 최대 연산수(worst case): 시간 복잡도를 계산할 때 의미있는 값
- 알고리즘의 공간적 효율은 작업에 필요한 메모리 양으로 측정한다.
## 정렬 알고리즘
- 비교적 간단한 (그러나 시간적 효율이 썩 좋지는 않은) 삽입정렬 (insertion sort) 알고리즘
	- 앞에서부터 차례로 부분정렬해 나간다.
	
	- 한 단계 진행할 때마다 검은색 숫자들 중 첫 숫자가 이동하여 정렬된 부분에 속하게 된다
![[Pasted image 20240514092513.png]]

## 삽입 정렬 함수 구현
void insert (int[] x, int i)를 어떻게 구현?
```java
// x[i]을 이미 정렬된 값들 x[0], x[1], ..., [i-1] 중 올바른 위치에 끼워 넣는다.

void insert (int[] x, int i) {

  int temp = x[i];     // 값을 임시 저장소에 보관.

      // temp 값을 끼워 넣을 장소를 찾음.

  int j = i-1;

  while ( j > = 0 && temp < x[j] ) { // and의 순서를 바꾸면 런타임 에러 발생

  x[j+1] = x[j];        // 오른쪽으로 이동 (복사).

  j--;

  }

  x[j+1]= temp;   // temp 값(x[i])을 올바른 위치에 끼워 넣음.

}

•
```

삽입정렬 완성
```java
배열 x의 앞부분 n개 원소를 정렬한다.

x[0], x[1], ..., x[n-1]을 정렬된 상태로 만든다.

public static void sort(int[] x, int n) { 

  for (int i = 1; i < n; i++)

  insert(x, i);

}

배열 전체를 정렬하려면 아래와 같이 호출한다.

  sort(x, x.length)
```

## 삽입정렬의 시간적 성능
- N번째 원소를 삽입하기 위해 ==최대 N-1번 비교하고 N-1번 이동해야 한다.

-> 복잡도(연산 횟수) 최대값

- 2 * (1 + 2 + 3 +… (N – 1)) = 2 * (N - 1) * N / 2 = (N-1)*N
	
	(비교하고 이동해야 하므로 두 개의 연산이 필요함 -> 2를 곱했다.)

- ==복잡도 (연산 횟수) 최대값은 N의 2차식으로 표현된다.

- ==N이 증가함에 따라 최대 복잡도가 빠르게 증가한다.

- ==배열이 이미 정렬되어 있는 경우, 최소 복잡도 = N-1

## 삽입정렬의 공간적 성능
- 배열이 있는 자리에서 원소들이 서로 자리바꿈만 하므로 (temp 외에는) 추가적인 공간을 사용하지 않는다

## 선형탐색

## 이진탐색
- 이진탐색은 선형 탐색보다 성능 굿
	-더 적은 비교 연산
	-더 짧은 실행 시간
==이진 탐색을 위해서는 배열이 미리 정렬되어 있어야 한다.
- 탐색해야할 데이터 갯수가 많을 때, 선형 탐색 대신 이진 탐색을 채택
![[Pasted image 20240514100422.png]]
반복1의 mid를 -1 하여 반복2의 high가 된다.
반복 2의 mid를 +1하여 반복3의 low가 된다.

## 탐색 성능
![[Pasted image 20240514100953.png]]
