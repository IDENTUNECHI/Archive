
# **배열 - Array**
#배열의특징, #Math클래스, #난수생성, #String을integer로바꾸기, #String비교판별, #StringBuilder 

## 배열의 특징
- 객체이다
- 같은 유형의 데이터를 여러 개 저장
- 연속적인 메모리 (주소 계산 효율을 위한)
- 이름을 갖는다
-  참조 변수를 통해 배열을 사용
- 배열이 구성되고 나면 배열의 크기는 고정
- 배열이 구성된 후 배열의 길이를 변경X

  ## 배열의 기본값
	-int [] myArray = new int[]; // 0이 들어있다.
	-double [] myArray = new double[]; // 0.0 이 들어있다.
	-boolean [] myArray = new boolean[]; // false이 들어있다.
	-char [] myArray = new char[]; // 문자형 0이 들어있다.

- (변수).length 속성은 배열에 할당된 메모리 셀의 갯수
	-메소드가 아닌 속성을 쓰는 이유
		String은 변할 수 있는 반면 배열의 크기와 길이가 
		고정되기 때문에 속도를 높이기 위해.

``` java
// 배열 코드 예시
Scanner input = new Scanner(System.in);
int[] a;
a = new int[10];

System.out.print("Enter 10 integers");

for (int i=0; i<a.length; i++)
	a[i] = input.nextInt(); // 입력된 값들을 a[1],...,a[9]에 차례로 저장

System.out.print("list in reverse");
// a[9]..a[8].. 저장된 값들을 차례로 출력
for (int i = a.length-1; i> =0; i--)
	System.out.print(a[i] + "");
System.out.println();

/** 선언, 배열, 생성, 초기화를 한꺼번에 할 수도 있다.
* ex) char [] letters = {'a', 'b', 'c'}; 
* 사용해야할 배열이 정해져 있을 때 사용하면 좋을 듯
/
```

```java
int[] a = {5, 4, 3, 2, 1};
int[] b = new int[5]; // defalut value 0이 들어있음
b = a;
/**  이때 a <- b 의 형태로 b가 a에 속해지므로 b의 배열은 쓸모가 없어짐
* 이런 배열은 자바시스템이 여유 있는 시간에 자동으로 메모리 회수
* 이 작업을 Garbage Collection 이라 지칭
*/
```

```java
int[] a = {5, 4, 3, 2, 1};
int[] b = {5, 4, 3, 2, 1};
int[] c = a;
a == b ? -> false
a == c ? -> true
// a에 들어있는 참조와 b에 들어있는 참조는 같지 않다.
// 즉 주소가 다르다.
```

```java
// for-each loop
int[] array = {1, 3, 5};
for (int n: array) // for each n in array
	System.out.print(n + " ");
// array의 각 원소가 차례로 n에 대입된다.
```

```java
import java.io.*;

import java.util.Scanner;

public class FileIn {

 public static void main(String args[]) throws FileNotFoundException {

  Scanner input = new Scanner(new File("D:/java/data.txt"));
 // 파일로 부터 데이터를 읽는다.

  int lineNumber = 1;

	while(input.hasNextLine()){ // 다음 줄이 있나??
		String line = input.nextLine(); //그 줄을 읽어라, String타입변환

		System.out.println("line " + lineNumber + " :" + line);

  lineNumber ++;

    }      
  }  
}
```

## Math 클래스
- 많은 static 메소드를 가짐.
- static이 아닌 메소드를 인스턴스 메소드라고 부름.
- 인스턴스 메소드는 어느 한 객체를 지정하여 그 객체에게 호출하는 메소드.
- static 메소드는 객체를 지정하지 않고 호출하는 메소드.
```java
static double abs(double a)  절댓값 반환
static double pow(double a, double b) 두 개의 값을 가지고 제곱 연산
static double max(double a, double b) 전달된 두 값을 비교해 큰 값을 반환
static double round(double a) 소수점 첫째 자리에서 반올림한 정수 반환

```

## 난수생성

```java
long seed = 10;
Random generator = new Random(seed);
for (int i = 1; i < =; 10; i++){
	System.out.print(generator.nextInt(100) + " ");
}

13 

```

## String을 integer로 바꾸기

```java
Scanner input = new Scanner(System.in);
System.out.print("두 개의 정수 입력");
String word1 = input.next();
String word2 = input.next();
System.out.println(word1+ word2);
int n1 = Integer.parseInt(word1);
int n2 = Integer.pareInt(word2);
System.out.println(n1+n2);

```


## String 비교

```java
String a = "Kangwon";

String b = "KANGWON";

System.out.println(a.equals(b));       // false

System.out.println(a.equalsIgnoreCase(b));   // true, 대소문자 무시!

String c = input.nextLine();

System.out.println("Kangwon".equals(c));

  // “Kangwon”이 입력된 단어와 같은가?

  // “Kangwon”도 String 객체이므로

  // “Kangwon”에게 String 메소드를 호출할 수 있다.
```

## StringBuilder


• String 객체는 한 번 만들어지면 그 내용이 바뀌지 않는다.

• 문자열의 내용이 여러 번 수정되는 경우 그 때마다 새 객체가 만들어진다.

• 객체를 새로 만드는 일은 컴퓨터에게 부담이 가는 일이다.

• 편집이 가능한 문자열 객체 = StringBuilder

```java
// 새 StringBuilder 인스턴스를 만든다.

StringBuilder builder = new StringBuilder();

// 문자열을 추가하는 작업을 반복한다.

for (int i = 0; i < 5; i++) {

    builder.append(“여름 ");

}

// String으로 변환한다.

String result = builder.toString();

// 결과를 출력한다.

System.out.println(result);
```

## 원소의 최댓값 최솟값 추출
```java
// 첫번째 for문을 사용해 max, min 변수룰 업데이트 해가며
//	최대 최소 찾기
import java.util.Scanner;  
  
public class Main{  
    public static void main(String[] args){  
        Scanner input = new Scanner(System.in);  
        int i;  
        int count = 0;  
        int j = 0;  
  
        int n = input.nextInt();  
        int [] a = new int[n];  
        for(i = 0; i< a.length; i++){  
            a[i] = input.nextInt();  
        }  
  
        int max = a[0];  
        int min = a[a.length-1];  
  
        for(j = 0; j < a.length; j++){  
            if(a[j] > max){  
                a[j] = max;  
                // max은 가장 첫번째 인덱스 값이므로 첫번째 인덱스 값부터   
// 비교하며 a[j]가 max 보다 작다면, a[j] = min 으로 업데이트  
            }  
  
            if (a[j] < min){  
                min = a[j];;  
                // min은 가장 마지막 인덱스 값이므로 첫번째 인덱스 값부터   
// 비교하며 a[j]가 min 보다 작다면, a[j] = min 으로 업데이트  
            }  
  
        }  
        System.out.print(min+" "+max);  
    }  
}
```

```java
import java.util.Scanner;  
import java.util.Arrays;  
// Arrays.sort() 메소드를 이용해 배열을 오름차순으로 정렬
public class Main{  
    public static void main(String[] args){  
        Scanner input = new Scanner(System.in);  
        int i;  
        int count = 0;  
        int j = 0;  
  
        int n = input.nextInt();  
        int [] a = new int[(int)n];  
        for(i = 0; i< a.length; i++){  
            a[i] = input.nextInt();  
        }  
        input.close();  
       Arrays.sort(a);  
       System.out.print(a[0]+" "+a[n-1]);  
  
    }  
}
```