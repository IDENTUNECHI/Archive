## 2차원 배열
- ex) 행렬을 구현할 때 2차원 배열로, 이미지
```java
int[][] table = new int[2] [3]; 
// 2차원 정수 배열을 가리키는 참조변수 선언

// 2x3 이차원 배열 생성

// (행이 두 개, 열이 세 개인 2차원 배열)
int[][] table = { {2, 4, 6}, {8, 10, 12} };
// 선언, 생성, 초기화를 한꺼번에 하는 방법
                   
```

```java
2차원 배열로 데이터를 읽어 들이는 예

  Scanner input = new Scanner(System.in);

  int [][] a = new int[5][4];

  for (int row = 0; row < 5; row++)

       for (int col= 0; col < 4; col++)

		  a[row][col] = input.nextInt();
```

### 2차원 배열의 내부 구조
- 2차원 배열은 배열들의 배열
	-처음은 주소값이 들어있는 참조 일차원 배열이 들어간다.
	![[Pasted image 20240507092249.png]]
	```java
배열의  어느 항목에 접근하려면 참조[index] 형식을 사용한다.

int[] a = new int[5];  // a는 배열을 가리키는 참조

a[2] <- 2번 방

table[0] // 배열을 가리키는 참조

table[0][2] <- 2번 방
	```

- ==메모리 연속되지 않아도 그 공간을 채울 수 있음??== 
- ==but, 문제는 속도가 느려짐==
- Java와 C/C++ 비교

- Java에서 배열은 메소드와 필드(속성)을 갖는 객체이나 C/C++에서 배열은 객체가 아님

- Java에서는 배열의 인덱스 범위를 벗어나면 index outside of the array boundaries 예외가 발생하나 C/C++에서는 “segmentation fault” 발생

- cf) C/C++에서의 배열은 연속된 메모리 공간을 사용

## java.util.Arrays 클래스
- toString(int[] a)
```java
improt java.util.Arrays;
public class ArrayDemo {
	publicc static void main(String[] args){
	int[] a = {1,2,3};
	System.out.println(Arrays.ToString(a));
}
--------------------------------------------------
[1, 2, 3]
```
- for-each loop
```java
improt java.util.Arrays;
public class ArrayDemo {
	publicc static void main(String[] args){
	int[] a = {{1, 2, 3},{6, 7}};
	for (int[] a: array2) // for each a in array2
	System.out.println(Arrays.ToString(a));
}
--------------------------------------------------
[1, 2, 3] //2차원 배열은 2차원 배열의 각 행에 해당하는
[6, 7]   // 일차원 배열들을 차례로 출력하는 방식으로 출력가능
```
- deepToStirng
```java
int[] a = {{1, 2, 3},{6, 7}};
System.out.println(Arrays.deepToString(a));

char[][][] b ={{{'a', 'b'}, {'c', 'd'}}, {{'1', '2'}, {'3', '4'}}}
System.out.println(Arrays.deepToString(b));
-------------------------
[[5, 6], [1, 2, 3]]
[[[a, b],[c, d]], [[1, 2], [3, 4]]]
```
## 객체 배열
- 객체 배열에는 객체를 가리키는 참조가 저장

## 배열을 반환하는 메소드
- 배열을 가리키는 참조를 반환하는 메소드
```java
public static void main(String[] args) {

  int[] intArray;  // int 배열을 가리키는 참조변수

  intArray = makeIntArray(5); 

  System.out.println(intArray[0]);

}

// 크기가 n인 int 배열을 구성하고 그 배열을 가리키는 참조변수를 반환한다.

public static int[] makeIntArray(int n) {

  int[] myArray = new int[n];

  myArray[0] = 11;

  return myArray;
  --------------------------
  makeIntArray 메소드가 리턴하면 참조변수인 myArray가 사라짐
  그러나 '메소드에서 만들어진 객체인 배열은 사라지지 않음.'
  intArray 참조변수가 배열을 가리키고 있기 때문에 GC(쓰레기 수거) 기능에 의해 메모리가 회수되지 않는다.
  

}
```
## 메소드 오버로딩(다중 정의)
- 한 클래스 속하는 두 개 이상의 메소드가 같은 이름을 가질 수 있다.
	-==파라미터가 달라져야함==
```java
/오버로딩된 메소드
double diagonal(double x, double y)

  // (0, 0)과 (x, y)간 거리를 구한다.

double diagonal(double x, double y, double z)

  // (0, 0, 0)과 (x, y, z)간 거리를 구한다
```


- 이럴 때 메소드들이 오버로딩됐다고 말한다.

- 오버로딩된 메소드들은 파라미터 리스트가 서로 달라야 한다.

- 오버로딩된 메소드들은 서로 다른 타입의 값을 반환할 수 있다.

- 아래의 두 메소드는 오버로딩이 아니다. 컴파일이 되지 않는다.
```java
int       MyMethod(int x)  
 double  MyMethod(int x)
```
-==자료형이 다르더라도 파라미터가 다르다면 컴파일X==